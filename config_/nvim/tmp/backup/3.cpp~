#define _XOPEN_SOURCE 700

#include <iostream>
#include <vector>
#include <optional>
#include <cmath>
#include <unistd.h>
#include <GL/glut.h>

using point = std::pair<int, int>;
using polygon = std::vector<point>;
using polygon_set = std::vector<polygon>;

static float angle{.0};
static polygon_set p_set;
static polygon current;
static int active_x{0}, active_y{0};
static int height{0}, width{0};
static bool draw_state{true};
static int v_x{0}, v_y{0};
//static int off_x{0}, off_y{0};
static polygon_set::iterator clk_itr;

void initalizer(void);
void display(void);
void reshape(int w, int h);
void draw_function(void);
void mouse_function(int key, int state, int x, int y);
int cross_product(int x1, int y1, int x2, int y2, int x3, int y3);
polygon_set::iterator clicked_polygon(point p);
int sgn(int x);

int
main (int argc, char **argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
	glutInitWindowSize(640, 480);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("draw");

	initalizer();

	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutIdleFunc(display);
	glutMouseFunc(mouse_function);

	glutPassiveMotionFunc([] (int x, int y)
			{
				// reverse y to get the coordinate system that we're used to
				y = height - y;

				if(draw_state)
				{
					active_x = x; // - off_x;
					active_y = y; // - off_y;
				}

				// get 'from' point for the translation vector - here we need it to prevent jumping
				v_x = x;
				v_y = y;
			});

	glutMotionFunc([] (int x, int y)
			{
				// reverse y to get the coordinate system that we're used to
				y = height - y;

				if(!draw_state)
				{
					// update translation offset
					//off_x += x - v_x;
					//off_y += y - v_y;

					// if we're in 'drag mode' perform the translation
					//glTranslatef(x - v_x, y - v_y, 0);
					if(p_set.end() != clk_itr)
						for(auto &e : *clk_itr)
						{
							e.first += x - v_x;
							e.second += y - v_y;
						}
					usleep(10);
				}

				// get 'from' point for the translation vector
				v_x = x;
				v_y = y;
			});

	glutMainLoop();
	return 0;
}


void initalizer(void)
{
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);
	glLineWidth(5);

	clk_itr = p_set.end();
}

void draw_function(void)
{
	// (0,0) for reference - used for testing purposes
	glColor3f(0.0, 1.0, 0.0);
	//glRectf(0.0, 0.0, 10.0, 10.0);

	// draw the complete polygons
	for(auto pgn : p_set)
	{
		glBegin(GL_POLYGON);
		glColor3f(0.2, 0.6, 0.7);

		for(auto e : pgn)
			glVertex2i(e.first, e.second);

		glEnd();
	}
}

void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	gluLookAt()

	glLoadIdentity();
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(.5);
	
	angle += 5;

	// draw complete polygons
	draw_function();

	// draw the 'in progress' lines of the current polygon
	glBegin(GL_LINE_STRIP);
		glLineWidth(10);
		glColor3f(0.4, 0.5, 0.9);
		for(auto e : current)
			glVertex2i(e.first, e.second);
		glVertex2i(active_x, active_y);
	glEnd();

	// swap the buffers
	glutSwapBuffers();
	glFlush();
}

void reshape(int w, int h)
{
	width = w;
	height = h;

	glViewport(0, 0, w, h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, w, 0, h);

	glutPostRedisplay();
}

void mouse_function(int key, int state, int x, int y)
{
	// inore on release button events
	if(GLUT_UP == state)
	{
		clk_itr = p_set.end();
		return;
	}

	y = height - y;
//	x -= off_x;
//	y -= off_y;

	switch(key)
	{
		case GLUT_MIDDLE_BUTTON:
		{
			// when we are leaving 'draw mode' finish the 'in progress' polygon
			if(draw_state)
				current.clear();
			draw_state = !draw_state;
			break;
		}
		case GLUT_LEFT_BUTTON:
		{
			std::cout << "mouse function: " << x << " " << y << std::endl;
			if(draw_state)
			{
				std::cout << "push back" << std::endl;
				current.push_back({x, y});
				active_x = x;
				active_y = y;
			}
			else
				clk_itr = clicked_polygon({x, y});
			break;
		}
		case GLUT_RIGHT_BUTTON:
		{
			if(!draw_state)
				break;
			std::cout << "push back poly" << std::endl;
			current.push_back({x, y});
			p_set.push_back(std::move(current));
			current.clear();
			break;
		}
	}
}

inline bool cross_product(point a, point b, point c)
{
	int a0{a.first}, a1{a.first}, a2{b.first}, a3{c.first};
	int b0{a.second}, b1{height}, b2{b.second}, b3{c.second};

	return 	(((a2 - a0)*(b1 - b0) - (b2 - b0)*(a1 - a0)) * ((a3 - a0)*(b1 - b0) - (b3 - b0)*(a1 - a0)) < 0)
			&& (((a0 - a2)*(b3 - b2) - (b0 - b2)*(a3 - a2)) * ((a1 - a2)*(b3 - b2) - (b1 - b2)*(a3 - a2)) < 0);
}

polygon_set::iterator clicked_polygon(point p)
{

	for(auto it = p_set.begin(); it != p_set.end(); ++it)
	{
		size_t i{1}, intr_count{0};
		for(; i < it->size(); ++i)
		{
			if(cross_product(p, (*it)[i-1], (*it)[i]))
				++intr_count;
		}

		if(cross_product(p, it->back(), it->front()))
			++intr_count;

		if(0 != intr_count % 2 && 0 != intr_count)
			return it;
	}

	std::cout << "returned end" << std::endl;
	return p_set.end();

}

int sgn(int x)
{
	return (0 < x) - (0 > x);
}
