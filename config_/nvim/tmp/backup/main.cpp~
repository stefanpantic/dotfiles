#include <iostream>
#include <cmath>
#include <vector>
#include <unistd.h>
#include <GL/glut.h>

/* width and height of the window */
static int width, height;

/* angle of rotation for the camera */
static float theta{0.0}, phi{0.0};

/* key states */
static float c_angle_xz{0.0}, c_angle_xy{0.0};
static float move_front{0.0}, move_strafe{0.0};
static int delta_x{0}, delta_y{0};

/* XZ position of camera */
static float eye_x{0.0}, eye_y{1.0}, eye_z{5.0};

/* vector for camera direction los - line of sight */
static float to_x{0.0}, to_y{1.0}, to_z{-1.0};

/* speed of player */
static float speed{0.2};

/* speed of camera */
static float mouse_speed{0.005};

/* jump indicator */
static bool in_air{false}, zenith{false};

/* 'snowman' rotation angle */
static float head_angle{0.0};
static float body_angle{0.0};

/* init function for cleaner code */
void init();

/* draw a snowman */
void draw_snowman(void);

/* calculate the direction and position of camera when doing continous move */
void calculate_direction(void);
void calculate_position_front(void);
void calculate_position_strafe(void);

/* jump function */
void jump(void);

/* declaration of callbacks */
void on_display();
void on_reshape(int w, int h);
void on_keypress_ascii(u_char key, int x, int y);
void on_keypress_special(int key, int x, int y);
void on_key_down(int key, int x, int y);
void on_key_up(int key, int x, int y);
void on_key_up_ascii(u_char key, int x, int y);
void on_mouse_press(int key, int state, int x, int y);
void on_mouse_move(int x, int y);


int
main (int argc, char **argv)
{
	/* initialize the window */
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_RGBA  |
						GLUT_DEPTH |
						GLUT_DOUBLE);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("Field of Snowmen 3D");
	glutSetCursor(GLUT_CURSOR_NONE);

	/* call the intitalizer */
	init();

	/* register callbacks */

	/* display callbacks */
	glutDisplayFunc(on_display);
	glutIdleFunc(on_display);
	glutReshapeFunc(on_reshape);

	glutWarpPointer(width/2, height/2);

	/* mouse callbacks */
	glutPassiveMotionFunc(on_mouse_move);
	//glutMouseFunc(on_mouse_press);

	/* keyboard callbacks */
	glutKeyboardFunc(on_keypress_ascii);
	glutKeyboardUpFunc(on_key_up_ascii);
	glutSpecialFunc(on_key_down);
	glutIgnoreKeyRepeat(1);
	glutSpecialUpFunc(on_key_up);

	/* start the game loop */
	glutMainLoop();

	return 0;
}


void init()
{
	/* set the clear color and enable depth */
	glClearColor(0, 0, 0, 0);
	glEnable(GL_DEPTH_TEST);
}

void draw_snowman(void)
{
	/* tranalate center and draw sphere */
	glPushMatrix();
	glColor3f(0.9, 0.9, 0.9);
	glTranslatef(0.0, 0.75, 0.0);
	glRotatef(body_angle, 0, 1, 0);
	glutWireSphere(0.75, 30, 30);

	/* tranalate center and draw smaller sphere */
	glColor3f(1, 0, 1);
	glRotatef(head_angle, 1, 1, 1);
	glTranslatef(0.0, 1.0, 0.0);
	glutWireSphere(0.25, 30, 30);
	glPopMatrix();

	body_angle += 0.1;
	head_angle += 0.2;
}

void calculate_direction(void)
{
	/* adjust the to angles accordingly */
	theta += c_angle_xz;
	phi += c_angle_xy;

	/* make sure to bind phi */
	if (phi >= 0.9) {
		phi = 0.9;
	} else if (phi <= -0.9) {
		phi = -0.9;
	}

	to_x = std::sin(theta);
	to_y = std::sin(phi);
	to_z = -std::cos(theta);
}

void calculate_position_front(void)
{
	/* */
	eye_x += move_front * to_x * speed;
	eye_z += move_front * to_z * speed;
}

void calculate_position_strafe(void)
{
	eye_x += move_strafe * to_z * speed;
	eye_z += move_strafe * -to_x * speed;
}

void jump(void)
{
	/* increase height untill we reach the zenith point */
	if (eye_y < 3.0 && !zenith) {
		eye_y += 0.1;
	} else if (eye_y >= 3.0){
		zenith = true;
	}

	/* if the zenith was reached start falling down */
	if (zenith && eye_y > 1.0) {
		eye_y -= 0.1;
	}

	/* but let's not fall to far down */
	if (1.0 == eye_y) {
		zenith = in_air = false;
	}

	std::cout << eye_y << std::endl;
}

void on_display()
{
	/* clear the color and depth buffers */
	glClear(GL_COLOR_BUFFER_BIT |
			GL_DEPTH_BUFFER_BIT);

	if (move_front) {
		calculate_position_front();
	}

	if (move_strafe) {
		calculate_position_strafe();
	}

	if (c_angle_xz) {
		calculate_direction();
	}

	if (c_angle_xy) {
		calculate_direction();
	}

	if (in_air) {
		jump();
	}

	/* reset the matrix */
	glLoadIdentity();

	/* set the camera */
	gluLookAt(
			eye_x, eye_y, eye_z,
			eye_x + to_x, eye_y + to_y, eye_z + to_z,
			0, 1, 0);

	/* draw the ground */
	glBegin(GL_QUADS);
		glColor3f(0.9, 0.9, 0.9);
		glVertex3f(-1000, 0, -1000);
		glVertex3f(-1000, 0, 1000);
		glVertex3f(1000, 0, 1000);
		glColor3f(0, 0, 1);
		glVertex3f(1000, 0, -1000);
	glEnd();

	/* draw some snowmen */
	for(int i = -3; i < 2; ++i)
	{
		for (int j = -1; j < 2; ++j)
		{
			glPushMatrix();
			glTranslatef(i * 10.0, 0, j * 10.0);
			draw_snowman();
			glPopMatrix();
		}
	}

	/* show the buffer we just drew on */
	glutSwapBuffers();
}

void on_reshape(int w, int h)
{
	/* capture the actual window width and height */
	width = w;
	height = h;

	/* center the pointer for tracking */
	glutWarpPointer(w/2, h/2);
	delta_x = width/2;
	delta_y = height/2;

	/* set the viewport */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glViewport(0, 0, w, h);
	gluPerspective(60, w/(float)h, 1, 1000);

	/* set the matrix mode to GL_MODELVIEW */
	glMatrixMode(GL_MODELVIEW);
}

void on_keypress_ascii(u_char key, int x, int y)
{
	(void)x;
	(void)y;

	switch (key)
	{
		/* a way to exit the program */
		case 27:
			exit(0);
		/* for controlling the camera direction */
		case 'w':
			c_angle_xy = 0.05;
			break;
		case 's':
			c_angle_xy = -0.05;
			break;
		case 'a':
			c_angle_xz = -0.05;
			break;
		case 'd':
			c_angle_xz = 0.05;
			break;
	}
}

void on_key_down(int key, int x, int y)
{
	(void)x;
	(void)y;

	switch (key)
	{
		/* controling player movement */
		case GLUT_KEY_UP:
			move_front = 0.5;
			break;
		case GLUT_KEY_DOWN:
			move_front = -0.5;
			break;
		case GLUT_KEY_LEFT:
			move_strafe = 0.5;
			break;
		case GLUT_KEY_RIGHT:
			move_strafe = -0.5;
			break;
	}
}

void on_key_up(int key, int x, int y)
{
	(void)x;
	(void)y;

	/* on key release stop moving player */
	switch (key)
	{
		case GLUT_KEY_LEFT:
		case GLUT_KEY_RIGHT:
			move_strafe = 0;
			break;
		case GLUT_KEY_UP:
		case GLUT_KEY_DOWN:
			move_front = 0;
			break;
	}
}

void on_key_up_ascii(u_char key, int x, int y)
{
	(void)x;
	(void)y;

	/* on key release stop moving camera */
	switch (key)
	{
		case 'w':
		case 's':
			c_angle_xy = 0;
			break;
		case 'a':
		case 'd':
			c_angle_xz = 0;
			break;
		case ' ':
			if (!in_air) {
				in_air = true;
			}
	}
}

/*
void on_mouse_press(int key, int state, int x, int y)
{
	(void)y;

	switch (key)
	{
		* left mouse button was pressed *
		case GLUT_LEFT_BUTTON:
			if (GLUT_UP == state) {
				mouse_x = x;
			}
			break;
	}
}
*/

void on_mouse_move(int x, int y)
{
	y = height - y;

	c_angle_xz = (x - delta_x) * mouse_speed;
	c_angle_xy = (y - delta_y) * mouse_speed;

	/* if we are in tracking mode, update the x and z angles and track the mouse */
	if (c_angle_xz) {
		calculate_direction();
	}

	if (c_angle_xy) {
		calculate_direction();
	}

	delta_x = x;
	delta_y = y;

	/* camera stops moving when the mouse stops moving */
	c_angle_xz = c_angle_xy = 0;
}
