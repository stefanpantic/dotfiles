#include <iostream>
#include <cmath>
#include <GL/glut.h>

static int width, height;

/* angle of rotation for the camera */
static float angle{0.0};

/* key states */
static float cont_angle{0.0}, cont_move{0.0};
static int mouse_x{-1};

/* XZ position of camera */
static float cam_x{0.0}, cam_z{5.0};

/* vector for camera direction */
static float los_x{0.0}, los_z{-1.0};

/* speed of camera */
static float speed{0.1};

/* snowman rotation angle */
static float head_angle{0.0};
static float body_angle{0.0};

/* init function for cleaner code */
void init();

/* draw a snowman */
void draw_snowman(void);

/* calculate the direction and position of camera when doing continous move */
void calculate_direction(void);
void calculate_position(void);

/* declaration of callbacks */
void on_display();
void on_reshape(int w, int h);
void on_keypress_ascii(u_char key, int x, int y);
void on_keypress_special(int key, int x, int y);
void on_key_down(int key, int x, int y);
void on_key_up(int key, int x, int y);
void on_mouse_press(int key, int state, int x, int y);
void on_mouse_move(int x, int y);


int
main (int argc, char **argv)
{
	/* initialize the window */
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_RGBA  |
						GLUT_DEPTH |
						GLUT_DOUBLE);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("Field of Snowmen 3D");
	glutSetCursor(GLUT_CURSOR_NONE);

	/* register callbacks */

	/* display callbacks */
	glutDisplayFunc(on_display);
	glutIdleFunc(on_display);
	glutReshapeFunc(on_reshape);

	/* mouse callbacks */
	glutMotionFunc(on_mouse_move);
	glutMouseFunc(on_mouse_press);
	glutKeyboardFunc(on_keypress_ascii);

	/* keyboard callbacks */
	glutSpecialFunc(on_key_down);
	glutIgnoreKeyRepeat(1);
	glutSpecialUpFunc(on_key_up);

	/* start the game loop */
	glutMainLoop();

	return 0;
}


void init()
{
	/* set the clear color and enable depth */
	glClearColor(0, 0, 0, 0);
	glEnable(GL_DEPTH_TEST);
}

void draw_snowman(void)
{
	/* tranalate center and draw sphere*/
	glPushMatrix();
	glColor3f(0.9, 0.9, 0.9);
	glTranslatef(0.0, 0.75, 0.0);
	glRotatef(body_angle, 0, 1, 0);
	glutWireSphere(0.75, 30, 30);

	/* tranalate center and draw smaller sphere*/
	glColor3f(1, 0, 1);
	glRotatef(head_angle, 1, 1, 1);
	glTranslatef(0.0, 1.0, 0.0);
	glutWireSphere(0.25, 30, 30);
	glPopMatrix();

	body_angle += 0.1;
	head_angle += 0.2;
}

void calculate_direction(void)
{
	angle += cont_angle;
	los_x = std::sin(angle);
	los_z = -std::cos(angle);
}

void calculate_position(void)
{
	cam_x += cont_move * los_x * speed;
	cam_z += cont_move * los_z * speed;
}

void on_display()
{
	/* clear the color and depth buffers */
	glClear(GL_COLOR_BUFFER_BIT |
			GL_DEPTH_BUFFER_BIT);

	if (cont_move) {
		calculate_position();
	}

	if (cont_angle) {
		calculate_direction();
	}

	/* reset the matrix */
	glLoadIdentity();

	/* set the camera */
	gluLookAt(
			cam_x, 1, cam_z,
			cam_x + los_x, 1, cam_z + los_z,
			0, 1, 0);

	/* draw the ground */
	glBegin(GL_QUADS);
		glColor3f(0.7, 0.7, 0.7);
		glVertex3f(-1000, 0, -1000);
		glVertex3f(-1000, 0, 1000);
		glVertex3f(1000, 0, 1000);
		glVertex3f(1000, 0, -1000);
	glEnd();

	/* draw some snowmen */
	for(int i = -8; i < 8; ++i)
	{
		for (int j = -1; j < 2; ++j)
		{
			glPushMatrix();
			glTranslatef(i * 10.0, 0, j * 10.0);
			draw_snowman();
			glPopMatrix();
		}
	}

	/* show the buffer we just drew on */
	glutSwapBuffers();
}

void on_reshape(int w, int h)
{
	/* capture the actual window width and height */
	width = w;
	height = h;

	/* set the viewport */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glViewport(0, 0, w, h);
	gluPerspective(60, w/(float)h, 1, 1000);

	/* set the matrix mode to GL_MODELVIEW */
	glMatrixMode(GL_MODELVIEW);

}

void on_keypress_ascii(u_char key, int x, int y)
{
	(void)x;
	(void)y;

	/* a way to exit the program */
	if  (27 == key) {
		exit(0);
	}
}

void on_key_down(int key, int x, int y)
{
	(void)x;
	(void)y;

	/* for controlling the camera and moving with the arrow keys */
	switch (key)
	{
		case GLUT_KEY_UP:
			cont_move = 0.5;
			break;
		case GLUT_KEY_DOWN:
			cont_move = -0.5;
			break;
		case GLUT_KEY_LEFT:
			cont_angle = -0.05;
			break;
		case GLUT_KEY_RIGHT:
			cont_angle = 0.05;
			break;
	}
}

void on_key_up(int key, int x, int y)
{
	(void)x;
	(void)y;

	switch (key)
	{
		case GLUT_KEY_UP:
		case GLUT_KEY_DOWN:
			cont_move = 0;
			break;
		case GLUT_KEY_LEFT:
		case GLUT_KEY_RIGHT:
			cont_angle = 0;
			break;
	}
}

void on_mouse_press(int key, int state, int x, int y)
{
	(void)y;

	switch (key)
	{
		/* left mouse button was pressed */
		case GLUT_LEFT_BUTTON:
			/* if the button was released update the angle and stop tracking */
			if (GLUT_UP == state) {
				angle += cont_angle;
				mouse_x = -1;
			/* if the button was pressed record the x coordinate */
			} else if (GLUT_DOWN == state) {
				mouse_x = x;
			}
			break;
	}

}

void on_mouse_move(int x, int y)
{
	(void)y;

	/* if we are in tracking mode, update the x and z angles and track the mouse */
	if (mouse_x >= 0) {
		cont_angle = (x - mouse_x) * 0.0005;

		los_x = std::sin(angle + cont_angle);
		los_z = -std::cos(angle + cont_angle);
	}
}
