1. Definisati maticni jezik i jezik podataka. Nabrojati maticne jezike i jezike podataka koje poznajete.
Jezik podataka je podskup jezika koji se odnosi na rad sa objektima u bazi podataka i operacije sa njima.
Maticni jezik predstavlja programski jezik (najcesce visi programski jezik ili asembler) u kome je ugnezden jezik podataka.
Maticni jezici su Java, C/C++, PL/I, Fortran, Cobol, APL2, Basic, Ada, Prolog...
Jezici podataka mogu da budu SQL, DB2, QUEL, DL/I...

2. Nabrojati poslove koje obavlja administrator baze podataka.
- formira bazu i implementira kontrolne strukture
- odgovoran za implementaciju odluka DA
- odgovoran za rad sistema, performanse
- definise konceptualnu semu tj. ucestvuje u logickom projektovanju baze
- definise unutrasnju seme tj. fizicki projektuje bazu
- komunikacira sa korisnicima (obezbedjivanje potrebnih podataka, konsultant pri projektovanju aplikacija, pomaze korisnicima koji imaju probleme pri radu sa bazom...)
- definise pravila zastite i integriteta
- definise procedure za uzimanje sigurnosnih kopija i oporavak baze
- vrsi podesavanje performansi

3. Sta su domeni? Nabrojati relacione domene koje pdrzava SQL.
Domeni predstavljaju skupove vrednosti i sinonim su za tipove podataka. Relacioni domeni koje podrzava SQL su:
- Brojevi
- Niske karaktera
- Niske bitova
- Datumi
- Vremena
- Kombinacija datuma i vremena
- Intervali godina/mesec
- Intervali dan/vreme

4. Definisati relaciju, zaglavlje i telo relacije.
Relacije su skupovi objekata sa kojima se barata u bazi podataka. Svaki od objekata Oi koji su u relaciji pripada nekom od domena Ti.
Za dati skup od n tipova, relacija nad tim tipovima se sastoji od zaglavlja i tela.
Zaglavlje relacije je skup od n atributa oblika Ai : Ti gde su Ai imena atributa relacije, a Ti odgovarajuca imena tipova (i=1,2,...,n).
Telo relacije je skup od m torki t gde je t skup komponenti oblika Ai : vi u kojima je vi vrednost tipa Ti (i=1,2,...,n).

5. Dati definiciju relaciono kompletnog jezika.
Jezik je relaciono kompletan ako je mocan kao i relaciona algebra, tj. ako bilo koja relacija predstavljiva u algebri moze da se predstavi i u tom jeziku.

6. Sta predstavlja teorijsku osnovu relacionog racuna?
Teorijsku osnovu relacionog racuna predstavlja predikatski racun.

7. Koje operatore cini minimalan skup operatora relacione algebre?
Minimalan skup operatora relacione algebre cine restrikcija, projekcija, proizvod, unija i razlika.

8. Sta predstavlja referencijalni ciklus? Koja SQL naredba je neophodna za njegovo formiranje?
Referencijalni ciklus je specijalni slucaj referencijalnog integriteta kod koga roditelj tabela i dete tabela predstavljaju istu tabelu,
ili se, u slucaju da u referencijalnom nizu postoji vise tabela, poslednja tabela referencijalnog niza referise na prvu tabelu.
Ako u ciklusu ucestvuje samo jedna tabela tada se on moze formirati naredbom CREATE TABLE. U suprotnom, naredba koja je neophodna za formiranje
referncijalnog ciklusa je ALTER TABLE pomocu koje se definisu spoljasnji kljucevi kojima se zatvara referencijalni ciklus.

9. Opisati pojam materijalizacije pogleda.
Materijalizacija pogleda je tehnika izvrsavanja upita nad pogledima pri cemu se kopija relacije kojom je definisan pogled cuva kao privremena tabela
u bazi podataka. Upiti se zatim izvrsavaju nad tom privremenom tabelom. Prednost ove tehnike nad tehnikom zamene
(umesto upita nad pogledom vrsi se izvrsavanje upita kojim se definise pogled nad osnovnim tabelama) je u znatno boljim performansama
(pogotovu u slucaju potrebe za visestrukim izvrsavanjem upita nad pogledom).

10. Ako si X i Y proizvoljni podskupovi skupa vrednosti relacije definisati kada Y funkcionalno zavisi od X.
Ako si X i Y proizvoljni podskupovi skupa vrednosti relacije R, tada Y funkcionalno zavisi od X, u oznaci X-? Y ako i samo ako je svakoj vrednost X u R pridruzena tacno jedna vrednost Y iz R.

11. Dati definiciju I, II i III normalne forme. Koje normalne forme pored ovih poznajete?
- Relaciona promenljiva je u 1. normalnoj formi ako i samo ako u svakoj vazecoj vrednosti tog relvar-a svaka torka sadrzi tacno jednu vrednost za svaki atribut.
- Relaciona promenljiva je u 2. normalnoj formi ako i samo ako je u 1. normalnoj formi i svaki nekljucni atribut je nereducibilno zavisan od primarnog kljuca
- Relaciona promenljiva je u 3. normalnoj formi ako i samo ako je u 2. normalnoj formi i svaki nekljucni atribut je netranzitivno zavisan od primarnog kljuca
Postoje I, II, III, Bojs-Kodova, IV i V normalna forma.

12. Dati definicije BCNF, 4NF i 5NF.
- Relaciona promenljiva je u BCNF ako i samo ako svaka netrivijalna levo-nereducibilna FZ ima kandidat za kljuc kao svoju levu stranu.
- Relaciona promenljiva R je u 4NF ako i samo ako je u BCNF i svaki put kada postoje podskupovi A i B atributa od R takvi da je zadovoljena
netrivijalna viseznacna zavisnost A -> -> B, tada su svi atributi od R takodje funkcionalno zavisni od A.
- Relaciona promenljiva R je u 5NF ako i samo ako R je u 4NF i svaka netrivijalna zavisnost spajanja koja vazi u R je posledica kandidata za kljuc u R, gde:
(a) Zavisnost spajanja *{A, B, ..., Z} u R je trivijalna akko je najmanje jedan od A, B, ..., Z skup svih atributa R.
(b) Zavisnost spajanja *{A, B, ..., Z} u R je posledica kandidata za kljuc relvara R akko je svaki od A, B, ..., Z nadkljuc za R.

12. Definisati pojam transakcije. Navesti i detaljnije opisati (ACID) osobine transakcija. Kada se za izvrsavanje skupa transakcija kaze da je serijalizovano?
Transakcija je logicka jedinica posla. Svaka transakcija mora da poseduje sledece osobine:
- Atomicnost. Transakcije su atomske - izvrsava se samo kompletan sadrzaj transakcije ili se ne izvrsava nista.
- Konzistentnost. Transakcije cuvaju konzistentnost baze tako sto transformisu korektno stanje baze u drugo korektno stanje. Pri tome nije obavezno cuvanje korektnosti
stanja u svakom od medjukoraka izvrsavanja.
- Izolacija. Transakcije su izolovane jedna od druge prilikom izvrsavanja.
- Trajanje. Po potvrdjivanju transakcije promene ostaju u bazi, cak i u slucaju pada sistema.
Izvrsavanje transakcija je serijalizovano ako se dobija isti rezultat kao da se te iste transakcije izvrsavaju jedna po jedna u unapred neodredenom redosledu izvrsavanja.

13. Navesti i ukratko opisati algoritam za oporavak sistema u slucaju pojave greske.
Moguci algoritmi za oporavak sistema u slucaju pojave greske su:
- Formiraju se dve liste transakcija: ponovljene i ponistene. U listu ponistenih inicijalno se upisuju sve transakcije koje su postojale u poslednjem uzetom kontrolnom slogu.
Zatim se pretrazuje log datoteka, pocevsi od poslednjeg kontrolnog sloga. Ako se naidje na pocetak transkacije T, tada se ona dodaje u listu ponistenih.
Ako je COMMIT pronadjen za transakciju T, tada se ona pomera iz liste ponistenih u listu ponovljenih.
Kada se dodje do kraja log datoteke liste ponovljenih i ponistenih sadrze transakcije koje treba ponoviti odnosno cije efekte treba ponistiti.
Da bi to izvrsio, sistem se vraca unatrag kroz log ponitavajuci efekat izvrsenja transakcija koje se nalaze u listi ponistenih, a zatim se krece od pocetka ka kraju
log datoteke ponavljajuci sadrzaj transakcija iz liste ponovljenih.
- ARIES algoritam. Formiraju se dve liste transakcija: ponovljene i ponistene, na isti nacin kao u prethodnom algoritmu.
Zatim se krene od pozicije u log datoteci koja je odredjena pri formiranju listi i ponove se sve transakcije tako da stanje baze odgovara stanju u trenutku pada sistema.
Nakon toga se poniste transakcije ciji sadrzaj nije potvrdjen.

14. Kojom naredbom moze da se definise spoljasnji kljuc tabele?
Naredbama CREATE TABLE xxx ... FOREIGN KEY ... ili
ALTER TABLE xxx ADD FOREIGN KEY ...

15. Opisati dvofazni protokol zakljucavanja resursa.
Dvofazni protokol zakljucavanja se izvrsava u skladu sa sledeim principima:
- Pre rada sa bilo kojim objektom transakcija mora da zahteva i dobije katanac nad tim objektom.
- Posle oslobadjanja katanca, transakcija nece vise zahtevati nikakve druge katance.
Faze pri zakljucavanju resursa su:
- Transakcija koja zeli da procita torku mora prvo da nad njom postavi S katanac
- Transakcija koja zeli da azurira torku mora prvo da nad njom postavi X katanac.
Alternativno, ako vec dri S katanac nad tom torkom, transakcija mora da zahteva unapredjenje S katanca u X katanac
- Ako je zahtev za postavljanjem katanca od strane transakcije B odbijen jer je u konfliktu sa vec postavljenim katancem
od strane transakcije A, transakcija B ide u stanje cekanja. B eka dok A ne oslobodi kljuc.
- X katanac se zadrzava do kraja transakcije (COMMIT ili ROLLBACK). S kljuc se, uobicajeno, zadrzava (najduze) do kraja transakcije.

16. Opisati mehanizme koji su ukljuceni u sistem zastite podataka u SQL jeziku.
Postoje dva mehanizma koja omogucuju zastite podataka: pogledi koji mogu biti korisceni da sakriju osetljive podatke od neautorizovanih korisnika, i podsistem za autorizaciju,
koji dopusta korisniku sa odredjenim pravima pristupa da pristupa zeljenim resursima i da ta prava selektivno i dinamicki prenosi na druge korisnike, kao i da preneta prava povuce.

17. Opisite nacin kontrole oporavka u distribuiranim bazama podataka.
Kontrola oporavka u distribuiranim bazama podataka moze da bude sprovedena na sledeci nacin:
Neka je distribuirani sistem zasnovan na mehanizmu zakljucavnja. Funkciju koordinatora vrsi sistem na kome je upit postavljen.
kooridnator komunicira sa svkaom lokacijom i naredjuje sta treba da se izvrsi. Smatra se da je trasakcija izvrsena ako je na svim lokacijama uspesno uradjeno potvrdjivanje tj. izvrsen COMMIT.
Da li je transakcija potvrdjena na svim lokacijama odredjuje koordinator na osnovu poruka koje dobija od lokacija u distribuiranom sistemu na jedan od sledeca dva nacina:
- ako lokacija ne posalje nikakvu poruku kooridinatoru pretpostavlja se COMMIT (pretpostavljeni COMMIT)
- ako lokacija ne posalje nikakvu poruku kooridinatoru pretpostavlja se COMMIT (pretpostavljeni COMMIT)

18. Definisati pojam arhitektura sistema baza podataka. Opisati ANSI/SPARC arhitekturu baze podataka.
Arhitektura sistema baza podataka je apstraktni opis njegovih komponenti i njihovih interakcija.
Prema ANSI/SPARC grupi arhitektura baze podataka sadrzi tri nivoa:
- Spoljacnji nivo koji definice nacin na koji individualni korisnik vidi podatke iz baze. Svaki korisnik ima na raspolaganju
maticni jezik u koji se ugradjuje jezik podataka pomo cu koga moze da vrci operacije nad podacima iz baze.
- Konceptualni nivo predstavlja ukupni informacioni kontekst baze podataka u obliku koji je na necto vicem nivou u poredjenju
sa nacinom kako su podaci fizicki smecteni u bazi. Podaci se predstavljaju nezavisno od od upitnog jezika i od hardvera na kome se nalaze.
- Unitracnji nivo koji predstavlja celokupnu bazu podataka na niskom nivou. Sastoji se od velikog broja razlicitih unutracnjih slogova.
Unutracnji izgled je definisan preko unutracnje sheme koja sadrzi ne samo definicije razlicitih slogova vec sadrzi i informacije o postojanju indeksa,
reprezentaciji sacuvanih polja, kako su fizicki smecteni sacuvani slogovi, itd.

19. Cemu sluze utility programi? Nabrojite neki od njih.
Utility programi su programi napisani od strane proizvodjaca softvera za upravljanje bazama podataka koji se koriste za razlicite administratorske poslove.
Ovi programi se mogu podeliti u dve grupe:
– spoljasnji (ili samostalne) koji se koriste u aplikacijama specijalnih namena (npr. rad sa log datotekom, itd.)
– unutrasnji (ili on-line)koji predstavljaju deo serverskog programa
Neki od utility programa su LOAD, IMPORT, REORG, RUNSTATS...

20. Sta je relaciona algebra?
Relaciona algebra je familija algebri sa dobro zasnovanom semantikom koja se koristi za modeliranje relacija (objekata) smestenih u relacionoj bazi podataka i za definisanje upita nad njima.
Skup objekata u algebri cine relacije, a operacije nad tim objektima su predstavljene poreko relacionih operatora. Rezultati primene relacionih operatora na relacije su takodje relacije.

21. Navesti sve operatore relacione algebre koje poznajete.
Operatori relacione algebre su:
– Restrikcija (selekcija)
– Projekcija
– Proizvod
– Unija
– Presek
– Razlika
– (Prirodno) Spajanje
– Delenje
– Rename (operator promene imena)
– Semijoin (poluspajanje)
– Extend (prosirenje)
– Summarize (operator sumiranja)

22. Sta je Kodov algoritam redukcije?
Kodov algoritam redukcije sluzi za prikaz da je algebra mocna bar koliko i racun i obratno.

23. Definisati pojam konkurentnosti u relacionim bazama podataka. Koje su prednosti konkurentnog rada?
Termin konkuretnost oznacava cinjenicu da SUBP dopusta da vise od jednog programa (transakcije) istovremeno pristupa istim podacima.
Prednosti konkurentnog rada su kra ce vreme odziva programa i pove canje broja programa koji mogu da zavrse obradu u istom vremenskom intervalu.

24. Definisati mrtvu petlju i nacine za njeno otkrivanje i razresavanje. Da li je moguce (i ako jeste kako) oporaviti aplikaciju (program) koja je prekinuta zbog mrtve petlje?
Mrtva petlja je situacija kada dve ili vise transakcija imaju postavljen katanac nad istim resursom sa nivoom zakljucavanja koji onemogu cava drugu transakciju da obavi zeljenu operaciju
nad tim resurtsom i nastavi sa radom. Ovakva situacija moze da se otkrije na razlicite nacine od kojih se najces ce koristi nacin pomo cu grafa cekanja. Mrtva petlja se razresava tako sto
se bar jedna od transakcija izabere kao zrtva ciji se efekat izvrsavanja ponistava. Na taj nacin se oslobode resursi koje je ta transakcija drzala i omogu cava nastavak rada ostalim
transakcijama koje dobijaju oslobodjene resurse.
Postupak za oporavak aplikacije prekinute zbog mrtve petlje je skok na pocetak transakcije koja je bila u toku kada je prekinuta i njeno ponovno izvrsavanje.

25. Ukratko opisati nacin funkcionisanja log protokola pisanje unapred.
Log protokol pisanje unapred predstavlja protokol kojim se u log datoteci zapisuju promene u relacionoj bazi podataka. Pri tome se zapis promena u bazi i zapis u log datoteku (o tim promenama)
 posmatraju kao dve odvojene operacije. Pre bilo kakvih promena u bazi podataka sve informacije o tim promenama moraju da se upisu u log datoteku. Tek ako je upis u log datoteku uspesno obavljen,
 preduzima se odgovaraju ca akcija nad bazom podataka. Takodje, pre potvrde transakcije svi log slogovi moraju da se upiu u fizicki log na disku.

26. Opisati ARIES algoritam.
ARIES algoritam je jedan od algoritama koji se koristi za oporavak sistema u slucaju pojave greske. ARIES funkcionise na slede ci nacin: formiraju se dve liste transakcija: ponovljene i ponistene.
U listu ponistenih inicijalno se upisuju sve transakcije koje su postojale u poslednjem uzetom kontrolnom slogu, dok je lista ponovljenih inicijalno prazna.
Pretrazuje log datoteka, pocevsi od poslednjeg kontrolnog sloga. Ako se naidje na pocetak transkacije T, tada se ona dodaje u listu ponistenih.
Ako je COMMIT pronadjen za transakciju T, tada se ona pomera iz liste ponistenih u listu ponovljenih.
Kada se dodje do kraja log datoteke liste ponovljenih i ponistenih sadrze transakcije koje treba ponoviti (tj. koje su uspesno zavrsile) odnosno cije efekte treba ponistiti
(tj. koje nisu uspesno zavrsile do trenutka pada sistema). padu sistema. U narednom koraku se krene od pozicije u log datoteci koja je odredjena pri formiranju listi i ponove se
sve transakcije tako da stanje baze odgovara stanju u trenutku pada sistema. Nakon toga se log skenira unatrag i (u obrnutom redosledu) ponistavaju sve transakcije ciji sadrzaj nije potvrdjen.

27. Koje nivoe izolacije kursora definise SQL standard?
SQL standard definise sledece nivoe izolacije
– READ UNCOMMITED
– READ COMMITED
– REPEATABLE READ

27. Detaljno opisati nivoe izolacije kursora koji postoje u RSUBP DB2.
Moguci nivoi izolacije u DB2 su:
- RR = Repeatable Read,
- RS = Read Stability,
- CS = Cursor Stability (predefinisano),
- UR = Uncommitted Read,
- NC = No Commit (samo na i seriji).

28. U kojim slucajevima pri radu sa transakcijama se javlja tzv. prljavo citanje a u kojima fantomi?

28. Na koji nacin (po standardu) moze biti narusena serijalizabilnost transakcija?
Prema SQL standardu, serializabilnost transakcija moze biti narusena kada se ne radi sa najvecim nivoom izolovanosti na sledeca tri nacina:
- Prljavo citanje (eng. dirty read). Transakcija T1 azurira neki slog, transakcija T2 cita taj slog a zatim T1 ponisti promene.
T2 je procitala slog koji ne postoji niti je formalno ikada postojao.
- Neponovljeno citanje (eng. nonrepeatable read). T1 cita slog, T2 azurira taj slog i T1 cita "isti" slog ponovo.
- Fantomi (eng. phantoms). Neka T1 cita skup slogova koji zadovoljavaju neki uslov. Neka T2 unese novi slog koji zadovoljava isti uslov. A
ko T1 sada ponovi zahtev vide ce slog koji ranije nije postojao fantomski slog.

29. Navedite intuitivnu definiciju potpunog spoljasnjeg spajanja.
Potpuno spoljasnje spajanje relacija A i B je relacija C u kojoj se javljaju, pored torki iz relacije A i B koje zadovoljavaju uslov spajanja,
i torke iz relacije A, odnosno relacije B koje ne zadovoljavaju uslov spajanja pri cemu se na mestu odgovaraju ce torke iz druge relacije nalaze NULL vrednosti.

30. Navedite intuitivnu definiciju levog i desnog spoljasnjeg spajanja.
Levo spoljasnje spajanje relacija A i B je relacija C u kojoj se javljaju, pored torki iz relacije A i B koje zadovoljavaju uslov spajanja, i torke iz relacije A,
koje ne zadovoljavaju uslov spajanja pri cemu se na mestu odgovarajuce torke iz relacije B nalaze NULL vrednosti.
Desno spoljasnje spajanje relacija A i B je relacija C u kojoj se javljaju, pored torki iz relacije A i B koje zadovoljavaju uslov spajanja, i torke iz relacije B,
koje ne zadovoljavaju uslov spajanja pri cemu se na mestu odgovarajuce torke iz relacije A nalaze NULL vrednosti.

31. Ukratko opisati faze u optimizaciji upita.
Pri optimizaciji upita se mogu izdvojiti slede ce faze:
- Prevodjenje upita na interni zapis. Pocetni upit se prevodi u internu reprezentaciju koja je pogodnija za obradu u racunaru.
Obicno se za predstavljanje koristi drvo upita ili drvo apstraktne sintakse
- Konverzija upita u kanonicki oblik. SQL upiti se dovode na (ekvivalentan) oblik koji je jednostavniji i efikasniji za primenu.
- Izbor kandidata za procedure niskog nivoa. Osnovna strategija je posmatranje izraza koji predstavlja upit kao niza operacija niskog nivoa
(spajanje, projekcija, restrikcija...) izmedju kojih postoje odreene zavisnosti. Za svaku od operacija niskog nivoa optimizator
ima na raspolaganju skup predefinisanih procedura za njihovu implementaciju. Svaka procedura ima pridruzenu formulu za odredjivanje cene kostanja,
obicno u zavisnosti od U/I operacija na disku, CPU vremena, velicine medjurezultata,...
Na osnovu informacija iz kataloga o teku cem stanju baze i medjusobnih zavisnosti operacija niskog nivoa optimizator bira jednu ili vise procedura za implementaciju svake od operacija niskog nivoa.
- Formiranje planova upita i izbor najjeftinijeg. Na osnovu predlozenog skupa procedura niskog nivoa, formira se skup kandidata za plan upita izmedju kojih se bira najbolji (tj. najjevtiniji).

32. Nabrojati ciljeve koje bi trebalo da zadovolji distribuirani sistem za rad sa relacionim bazama podataka.
Ciljevi koje bi trebalo da zadovolji distribuirani sistem za rad sa relacionim bazama podataka su:
- Lokalna autonomija
- Nepostojanje centralnog sistema
- Veca pouzdanost i raspolozivost
- Nezavisnost od lokacije
- Nezavisnost od fragmentacije podataka
- Nezavisnost replikacije
- Distribuirana obrada upita
- Distribuirano upravljanje transakcijama
- Nezavisnost od hardvera
- Nezavisnost od operativnog sistema
- Nezavisnost od nacina umrezavanja
- Nezavisnost od tipa SUBP

33. Navesti SQL ekvivalente operatora relacione algebre iz kojih se vidi da je SQL relaciono kompletan jezik.
SQL je relaciono kompletan jer je mo ´can koliko i relaciona algebra. SQL ekvivalenti osnovnih operatora relacione algebre su:
Algebra === SQL:
A WHERE P === SELECT * FROM A WHERE P
A{x,y,...,z} === SELECT DISTINCT x, y, ..., z FROM A
A TIMES B === A CROSS JOIN B
A UNION B === SELECT * FROM A UNION SELECT * FROM B
A MINUS B === SELECT * FROM A EXCEPT SELECT * FROM B
A RENAME x AS y === SELECT x AS y FROM A

34. Sta je sigurnost podataka? Navesti vrste dozvola u podsistemu za autorizaciju koje se odnose na osnovne tabele i poglede.
Sigurnost podataka predstavlja zastitu podataka od neautorizovanog pristupa, promene ili unistenja.
Vrste dozvola u podsistemu za autorizaciju koje se odnose na osnovne tabele i poglede mogu da budu:
– Dozvole koje se odnose na citanje podataka ("dozvole za SELECT")
– Dozvole koje se odnose na azuriranje podataka ("dozvole za UPDATE"). Pri tome ova vrsta dozvola moze da se odnosi i na pojedinacne kolone tabele odnosno pogleda.
– Dozvole koje se odnose na brisanje sadrzaja tabele ili pogleda ("dozvole za DELETE")
– Dozvole koje se odnose na unosenje podataka ("dozvole za INSERT")
– Dozvole koje se odnose na kontrolu nad objektom ("dozvole za CONTROL"). Ukljuuju dozvolu za brisanje objekta, davanje i ukidanje dozvola za rad.
Dozvole koje se odnose samo na osnovne tabele su:
– ALTER (dozovola za izvrsavanje ALTER TABLE naredbe)
– INDEX (dozvola za izvrsavanje CREATE INDEX naredbe)
– REFERENCES (za formiranje/brisanje spoljasnjeg kljuca koji referise tu tabelu kao roditelj tabelu)

35. Navesti funkcije SUBP-a.
Najvaznije funkcije SUBP-a su:
- Definisanje podataka
- Obrada podataka
- Optimizacija izvrsavanja upita
- Obezbedjivanje zastite i integriteta podataka
- Obezbedjivanje konkurentnog pristupa podacima i oporavka podataka
- Formiranje kataloga podataka
- Obezbedjivanje korisnickog interfejsa
- Izvodjenje drugih akcija u svrhu obezbedjivanja sto efikasnijeg rada

36. Navedite definiciju primarnog i spoljasnjeg kljuceva relacije.
Primarni kljuc je jedan od kandidata za kljuc. Kandidat za kljuc neke relacije R je skup atributa X ako zadovoljava:
- pravilo jedinstvenosti: ne smeju da postoje dve torke u relaciji R koje imaju iste vrednosti za X, i
- pravilo minimalnosti: ne postoji pravi podskup Y skupa X tako da za Y vazi pravilo jedinstvenosti.
Spoljasnji kljuc Relacije R je skup atributa te relacije cije vrednosti odgovaraju vrednostima nekog od kandidata za kljuc relacije R1.

37. Na osnovu vrednosti kojih promenljivih moze da se odredi da li je postavljeni upit korektno izvrsen?
Koje vrednosti tih promenljivih su znacajne?

37. Kako na osnovu vrednosti promenljive SQLCODE mozete da odredite da li je upit koji se izvrsava korektan?
Sta znaci kada se pri izvrsavanju upita dobije vrednost SQLCODE promenljive +100 a sta kada se dobije -911?
Ako je vrednost SQLCODE dobijena na kraju izvrsavanja upita jednaka 0 tada je upit korektno izvrsen. Ako je vrednost manja od 0, nastupila je greska, a ako je veca od 0 u pitanju je upozorenje.
Vrednost SQLCODE =+100 oznacava da se pri izvrsavanju naredbe za izdvajanje podataka iz tabele (SELECT ili FETCH) doslo do kraja rezultujuce tabele i da vise nema slogova koji bi mogli da budu procitani.
Vrednost SQLCODE=-911 oznacava da je aplikacija zapala u mrtvu petlju i da je prekinuta od strane SUBP-a.

38. Formalno dokazati: A UNION (A INTERSECT B) = A
pretpostavimo: x e Au(AnB), odatle
x e A ili x e AnB, tj
x e A ili (x e A i x e B), sledi
Au(AnB) c A (1)
pretpostavimo: x e A, onda je tacno i
x e A ili x e AnB, pa
x e Au(AnB), sledi
A c Au(AnB) (2)
iz (1) i (2) => Au(AnB) = A sto je trebalo dokazati.

39. Formalno dokazati: A INTERSECT (A UNION B) = A
pretpostavimo: x e An(AuB), odatle
x e A i x e AuB, tj
x e A i (x e A ili x e B), sledi
An(AuB) c A (1)
pretpostavimo: x e A, onda je tacno i
x e A i x e AuB, pa
x e An(AuB), sledi
A c An(AuB) (2)
iz (1) i (2) => An(AuB) = A sto je trebalo dokazati.

40. Formalno dokazati Da je unija distributivna preko preseka
Au(BnC) = (AuB)n(AuC) ?
pretpostavimo: x e Au(BnC), sledi
x e A ili (x e B i x e C), sledi
(x e A ili x e B) i (x e A ili x e C), dakle
x e (AuB)n(AuC)

41. Formalno dokazati Da je presek distributivan preko unije
An(BuC) = (AnB)u(AnC) ?
pretpostavimo: x e An(BuC), sledi
x e A i (x e B ili x e C), sledi
(x e A i x e B) ili (x e A i x e C), dakle
x e (AnB)u(AnC)

42. Formalno dokazati Da je su spajanje i unija asocijativni, a da razlika nije asocijativna operacija.
Au(BuC) = (AuB)uC ?
pretpostavimo: x e Au(BuC), sledi
x e A ili (x e B ili x e C), sledi
(x e A ili x e B) ili x e C, dakle
x e (AuB)uC
A\(B\C) != (A\B)\C ?
neka su A, B, C c X, tada je
A\B=AnB' gde je B' = X\B, sledi
(1) (A\B)\C = (AnB')nC' = AnB'nC'
(2) A\(B\C) = An(BnC')' = An(B'uC'') = (AnB')u(AnC) = (AnB'n(CuC'))u(An(BuB')nC) = (AnB'nC)u(AnB'nC')u(AnBnC) = (AnB'nC')u(An(BuB')nC) = (AnB'nC')u(AnC)
iz (1) i (2) => (AnB'nC') = (AnB'nC')u(AnC) sto je u opstem slucaju kontradikcija!

43. Formalno dokazati Da se presek moze predstaviti preko razlike.
AnB = A/(A/B)
