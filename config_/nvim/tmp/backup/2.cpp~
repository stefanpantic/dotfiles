#include <iostream>
#include <vector>
#include <tuple>
#include <cmath>
#include <GL/glut.h>

// convenience aliases
using point = std::tuple<int, int, int>;
using point_set = std::vector<point>;

// global variables
static int width{0}, height{0};
static float x{0}, z{1};
static float lx{0}, lz{-1};
static float angle{0};



// intializer function -- called once
void initializer_function();

// callback functions for glut
void on_display();
void on_reshape(int w, int h);
void on_mouse(int key, int state, int x, int y);
void on_mouse_move(int x, int y);
void on_keypress(u_char key, int x, int y);

int
main (int argc, char **argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("first 3D");

	initializer_function();

	glutDisplayFunc(on_display);
	glutIdleFunc(on_display);
	glutReshapeFunc(on_reshape);
	glutKeyboardFunc(on_keypress);
	glutMouseFunc(on_mouse);
	glutPassiveMotionFunc(on_mouse_move);

	glutMainLoop();

	return 0;
}

void initializer_function()
{
	glClearColor(0, 0, 0, 0);
	glEnable(GL_DEPTH_TEST);
	glutSetCursor(GLUT_CURSOR_NONE);
	glLineWidth(3);
}

void on_display()
{
	glClear(	GL_COLOR_BUFFER_BIT |
				GL_DEPTH_BUFFER_BIT);


	// set the camera
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(
			x, 1, z,
			x + lx, 1, z + lz,
			0, 1, 0
			);


	// Draw ground
	glColor3f(0.7, 0.7, 0.7);
	glBegin(GL_QUADS);
		glVertex3f(-100.0f, -1.0f, -100.0f);
		glVertex3f(-100.0f, -1.0f,  100.0f);
		glVertex3f( 100.0f, -1.0f,  100.0f);
		glVertex3f( 100.0f, -1.0f, -100.0f);
	glEnd();

	// draw some cubes
	glPushMatrix();
	glColor3f(1, 1, 0);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glRotatef(angle, 0, 1, 0);
	glutSolidCube(1);
	glPopMatrix();

	angle += 500000000;


	glutSwapBuffers();
}

void on_reshape(int w, int h)
{
	width = w;
	height = h;

	glViewport(0, 0, width, height);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60.0f, width/(float)height, 0.1f, 100.0f);
}

void on_mouse(int key, int state, int x, int y)
{

}

void on_mouse_move(int x, int y)
{

}

void on_keypress(u_char key, int x, int y) {

	float fraction = 0.1f;

	switch (key) {
		case 'h' :
			angle -= 0.1f;
			lx = sin(angle);
			lz = -cos(angle);
			break;
		case 'l' :
			angle += 0.1f;
			lx = sin(angle);
			lz = -cos(angle);
			break;
		case 'k' :
			x += lx * fraction;
			z += lz * fraction;
			break;
		case 'j' :
			x -= lx * fraction;
			z -= lz * fraction;
			break;
		case 27:
			exit(0);
	}
}
